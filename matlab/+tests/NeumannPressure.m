classdef NeumannPressure < muscle.AModelConfig
    % Tests the force generated by an isometrically fixed muscle
    % 
    % Fix both sides and activate to several max pressure values x[MPa].
    % Should give a overall force of x[N] on both sides.
    
    methods
        function this = NeumannPressure(version)
            if nargin < 1 
                version = 1;
            end
            % Creates a Debug simple muscle model configuration.
            this = this@muscle.AModelConfig;
            this.addOption('Version',version);
            this.init;
        end
        
        function configureModel(this, m)
            configureModel@muscle.AModelConfig(this, m);
%             sys = m.System;
            %f = sys.f;
            m.T = 100;
            m.dt = 1;
            % Kleine Visko für schnelle einstellung des gleichgewichts
            m.DefaultMu(1) = .1;%1e-4;
            % "Passende" Mooney-Rivlin parameter so dass das element nicht
            % allzu sehr degeneriert
            m.DefaultMu([9 10]) = .1;
            % Genau lösen!
            m.ODESolver.RelTol = 1e-7;
            m.ODESolver.AbsTol = 1e-7;
            m.DefaultInput = 1;
        end
        
        function P = getBoundaryPressure(this, elemidx, faceidx)
            % Determines the neumann forces on the boundary.
            %
            % The unit for the applied quantities is megaPascal [MPa]
            %
            % In the default implementation there are no force boundary
            % conditions.
            P = [];
            if elemidx == 1 && faceidx == 2
               P = eye(3);
            end
        end
        
        function u = getInputs(this)
            u = {this.getAlphaRamp(this.Model.T/2,1)};
        end
    end
    
    methods(Access=protected)
        
        function geo = getGeometry(this)
            % Single cube with same config as reference element
            [pts, cubes] = geometry.Cube8Node.DemoGrid([0 1],[0 1],[0 1]);
            geo = geometry.Cube8Node(pts, cubes);
            geo = geo.toCube27Node;
        end
        
        function displ_dir = setPositionDirichletBC(this, displ_dir)
            geo = this.PosFE.Geometry;
            displ_dir(1,geo.Elements(1,geo.MasterFaces(1,:))) = true;
            displ_dir(:,geo.Elements(1,geo.MasterFaces(1,5))) = true;
        end
        
        function anull = seta0(this, anull)
            if this.Options.Version == 2
                anull(1,:,:) = 1;
            end
        end
    end
    
    methods(Static)
        function res = test_NeumannPressure
            for version = 1:2
                a = tests.NeumannPressure(version);
                m = a.createModel;
                if version == 1
                    m.setGaussIntegrationRule(4);
                end

                B = m.System.B.getMatrix(1);
                res = norm(sum(B) - 1) < 1e-10;
                extfidx = find(B);

                f1 = m.getPositionDirichletBCFaceIdx(1,1);
                mu = m.DefaultMu;
                maxf = [.1 rand(1,5)*.1];
                for k=1:length(maxf)
                   mu(3) = maxf(k); 
                   [t,y] = m.simulate(mu,1);
                   pdf = m.getResidualForces(t,y);
%                    m.plot(t,y,'DF',pdf,'MR',true,'Pause',2); %,'Lambdas',true
%                    m.plot(t,y,'F',2);

                   force_l = sum(pdf(f1,:),1);
%                    figure;
%                    plot(t,force_l);

                   % See that the forces at the pulled side match (at the end)
                   fyend = m.System.f.evaluate(y(:,end),t(end));
                   res = res && norm(maxf(k)*B(extfidx) + fyend(extfidx)) < 1e-10;

                   fprintf('Ext force on side %g[N] => Force left %gN\n',...
                       maxf(k),force_l(end));
                   res = res && norm(maxf(k)-force_l(end)) < 1e-8;
                end
            end
        end        
    end
    
end

